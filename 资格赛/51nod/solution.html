<div>由于求的是在原串中出现次数的总和，那么可以枚举S在原串中出现的位置，然后求出原串有多少种。可以发现，如果把S从那个位置中拿掉之后，剩下来的串还是满足偏串定义的。这个是为什么呢？假设原串是T，而S出现在k的位置，那么原串的形状是这样的T[0...k-1]+S+T[k+len(s)...n-1]</div><div>对于T[0...k-1]这个串，因为他的前缀是原串前缀的一部分，所以它的前缀中0和1的差是和原串一样的，而对于T[0...k-1]+T[k+len(s)...n-1]这个串中结尾在[k+len(s)，n-1]这个区间的前缀，因为S是一个偏串，里面的0和1数目相等，所以把它从原串中拿掉之后，并不影响到后面0和1数目的差，所以结尾在[k+len(s)，n-1]这一区间内的前缀中，0和1数目的差值是和原串一样的。因而T[0...k-1]+T[k+len(s)...n-1]还是一个偏串。</div><div>所以只要求一下n-len(s)的偏串有多少种即可了。</div><div>记&nbsp;<span name="ace" lang="latex"><span>m=\frac{n-len(s)}{2}</span></span>&nbsp;。</div><div>这个问题可以转化为在一个平面座标系中，每次只向右走一步或者向上走一步，但是不能跨过对角线，从(0,0)走到(m,m)的方法数，这个答案是卡特兰数&nbsp;<span name="ace" lang="latex"><span>\frac{1}{m+1}C_{2m}^m</span></span>&nbsp;</div><div>又S在原串出现的位置有n-len(s)+1种，所以最后答案是&nbsp;<span name="ace" lang="latex"><span>\frac{2m+1}{m+1}C_{2m}^m=C_{2m+1}^m=\frac{(2m+1)!}{(m+1)!~m!}</span></span>&nbsp;</div><div>这个问题是如何求阶乘，由于m是比较大的，对一个大素数取余，可以用分段打表法来求，按照1百万分段，先计算出fac[1000000*k]的值，然后对于一个数字n从fac[n/1000000*1000000]这个位置暴力求到n，这样的复杂度是O(1000000)。</div><div>最后对分母部分求逆元即可。</div><div>另外注意一下corner case.</div>